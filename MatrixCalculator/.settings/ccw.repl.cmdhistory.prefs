cmdhistory=["(doc file)" "\\n(defn write-into-file\\n  [file-name]\\n  (spit file\:file-name (Create-laze-Matrix-const-size 10 10))\\n)" "\\n(defn write-into-file\\n  [file-name]\\n  (spit (file\:file-name) (Create-laze-Matrix-const-size 10 10))\\n)" "\\n(defn write-into-file\\n  [file-name]\\n  (spit (writer file-name) (Create-laze-Matrix-const-size 10 10))\\n)" "(write-into-file mymat)" "\\n(defn write-into-file\\n  [filename]\\n  (spit filename (Create-laze-Matrix-const-size 10 10))\\n)" "(write-into-file mymat)" "(fn [filename]\\r\\n(spit filename snapshot)\\n)" "(fn [filename]\\r\\n(spit filename \\"snapshot\\")\\n)" "(defn r [filename]\\r\\n(spit filename \\"snapshot\\")\\n)" "(r f)" "(r \\"g\\")" "(defn write-into-file\\r\\n  [file-name]\\r\\n  (spit 'file-name (Create-laze-Matrix-const-size 10 10))\\r\\n)" "(defn write-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-laze-Matrix-const-size 10 10))\\r\\n)" "(write-into-file \\"mat_A_10_10\\")" "(write-into-file \\"mat_B_10_10\\")" "(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )" "(input1 \\"mat_A_10_10\\")" "\\n\\n(defn run-from-file\\n[file-name mat1 mat2]\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\n)" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input1) (input2))" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input1 mat_A_10_10) (input2 mat_B_10_10))" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input1 \\"mat_A_10_10\\") (input2 \\"mat_B_10_10\\"))" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input) (input))" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input1 \\"mat_A_10_10\\") (input2 \\"mat_B_10_10\\"))" "(input1 \\"mat_A_10_10\\")" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input1 \\"mat_A_10_10\\") (input2 \\"mat_B_10_10\\"))" "(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )" "\\n\\n\\n(run-from-file \\"functions.txt\\" (input1 \\"mat_A_10_10\\") (input2 \\"mat_B_10_10\\"))" "(ShowMatrix(run \\"++\\" (input) (input)  ))" "(clojure.core/ns MatrixCalculator.exampels)\\n(ShowMatrix(run \\"*\\" (input) (input)  ))\\n(clojure.core/ns MatrixCalculator.core)" "\\n\\n(ShowMatrix(run \\"*\\" (input) (input)  ))" "(clojure.core/ns MatrixCalculator.exampels)\\n(ShowMatrix(run \\"*\\" (input) (input)  ))\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ns MatrixCalculator.exampels\\n  [MatrixCalculator.core ])\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ns MatrixCalculator.exampels\\n  \:use MatrixCalculator.core )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ns MatrixCalculator.exampels\\n  (MatrixCalculator.core) )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ns MatrixCalculator.exampels\\n  ([MatrixCalculator.core]) )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ns MatrixCalculator.exampels\\n  (\:use [MatrixCalculator.core]) )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ShowMatrix(run \\"*\\" (input) (input)  ))\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(input2 \\"mat_B_10_10\\")\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ShowMatrix(run \\"-\\" (input) (input)  ))\\n(clojure.core/ns MatrixCalculator.core)" "(doc comp)" " (defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (comp mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )" " (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\n     [mat] (comp count transpose mat) \\r\\n     )" " (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] (comp count transpose mat) \\r\\n     )" "(col-number matrix1)" "(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   }\\n  \\r\\n  \\r\\n\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n(defn Create-laze-Matrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col (rand-int 10)  step (rand-int 10)]\\r\\n    (loop [ result [] row (rand-int 10)]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n(defn Create-laze-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(vector? (first coll))]} \\r\\n     (apply map vector coll))\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n> (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y)]}  \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (count mat) )\\r\\n     )\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\n     [mat] (comp count (transpose mat)) \\r\\n     )" "(defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\n     [mat] (comp count (transpose mat)) \\r\\n     )\\n " "(col-number matrix1)" "(doc comp)" "(defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\n     [mat] ((comp count transpose )mat) \\r\\n     )" "(col-number matrix1)" "(col-number input)" "(col-number (inpu))" "(col-number (input))" "(col-number (input mat_A_10_10))" "(col-number (input1 mat_A_10_10))" "(col-number (input1 \\"mat_A_10_10\\"))" "(deftest test-MatrixSub\\r\\n  is [x y] (\= x y)\\r\\n  [0] (run \\"-\\" (input) (input))\\r\\n  )" "(deftest test-MatrixSub\\r\\n  is [x y] (\= x y)\\r\\n  [0] (run \\"-\\" matrix1 matrix1)\\r\\n  )" "(deftest test-MatrixSub\\r\\n  ( is [x y] (\= x y)\\r\\n  [0] (run \\"-\\" matrix1 matrix1)\\r\\n  )\\n  )" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       [0] (run \\"-\\" matrix1 matrix1)\\r\\n       )\\n  )" "(run-tests\\n  )" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       [0] (run \\"-\\" (input) (input))\\r\\n       )\\n  )" "(run-tests\\n  )" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       0 (run \\"DP\\" \\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input \\"mat_B_10_10\\"))\\n       )\\r\\n   )\\n )" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       0 (run \\"DP\\" \\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n   )\\n )" "(run-tests\\n  )" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n   )\\n )" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\n )" "(run-tests\\n  )" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y)]}  \\r\\n      if ( (and (vector? x) vector? y) \\r\\n     (reduce + (pmap * x y)))\\n      (print \\"both inputs must be vectors\\") \\r\\n )" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y)]}  \\r\\n      (if  (and (vector? x) vector? y) \\r\\n     (reduce + (pmap * x y)))\\n      (print \\"both inputs must be vectors\\") \\r\\n )" "(dot-product [1 2 3] [1 2 3])" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y)]}  \\r\\n      (if  (and (vector? x) vector? y) \\r\\n     (reduce + (pmap * x y))\\n      (print \\"both inputs must be vectors\\") \\n      )\\r\\n )" "(dot-product [1 2 3] [1 2 3])" "(dot-product matrix1 matrix1)" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (vector? x) (vector? y)]}  \\r\\n     (reduce + (pmap * x y)))" "(dot-product [1 2 3] [1 2 3])" "(dot-product matrix1 matrix1)" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (float? (first x)) (float? (first y))]}  \\r\\n     (reduce + (pmap * x y)))" "(dot-product matrix1 matrix1)" "(dot-product [1 2 3] [1 2 3])" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}  \\r\\n     (reduce + (pmap * x y)))" "(dot-product [1 2 3] [1 2 3])" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (not\= 1 (row-number x)) (not\= 1 (row-number y))]}  \\r\\n     (reduce + (pmap * x y)))" "(dot-product [1 2 3] [1 2 3])" "(dot-product matrix1 matrix1)" " (defn dot-product [x y]\\r\\n      {\:pre [;(not\= [] x) (not\= [] y) \\n             (not\= 1 (row-number x)) (not\= 1 (row-number y))]}  \\r\\n     (reduce + (pmap * x y)))" "(dot-product matrix1 matrix1)" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             ]};(not\= 1 (row-number x)) (not\= 1 (row-number y))]}  \\r\\n     (reduce + (pmap * x y)))" "(dot-product matrix1 matrix1)" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (not\= 1 (row-number x)) (not\= 1 (row-number y))]}  \\r\\n     (reduce + (pmap * x y)))" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (not\= 1 (row-number x)) (not\= 1 (row-number y))]}  \\n      (print \\"hello\\") \\r\\n     (reduce + (pmap * x y)))" "(dot-product matrix1 matrix1)" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}  \\n      (print \\"hello\\") \\r\\n     (reduce + (pmap * x y)))" "(dot-product matrix1 matrix1)" "(dot-product [1 2 3] [1 2 3])" "(row-number [1 2 3])" "(row-number matrix1)" "(matrix1)" "matrix1" "(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   }\\n  \\r\\n  \\r\\n\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n(defn Create-laze-Matrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col (rand-int 10)  step (rand-int 10)]\\r\\n    (loop [ result [] row (rand-int 10)]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n(defn Create-laze-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(vector? (first coll))]} \\r\\n     (apply map vector coll))\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y)]}  \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if(vector? (first mat))\\n       (count mat) )\\n            1);if\\r\\n     )" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if(vector? (first mat))\\n       (count mat) )\\n            1);if\\r\\n     )" "(row-number matrix1)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\r\\n       (count mat) )\\r\\n            1);if\\r\\n     )" "(row-number matrix1)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\r\\n       (count mat) 1)\\r\\n            );if\\r\\n     );defn" "(row-number matrix1)" "(row-number [1 2 3])" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}  \\n      (print \\"hello\\") \\r\\n     (reduce + (pmap * x y)))" "(row-number [1 2 3])" "(dot-product [1 2 3])" "(dot-product [1 2 3] [1 2 3])" "(dot-product matrix1 matrix1)" "(col-number [1 2 3])" "(row-number [1 2 3])" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     ;{\:pre [(vector? (first coll))]} \\r\\n     (apply map vector coll))" "(transpose [1 2 3])" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     ;{\:pre [(vector? (first coll))]} \\r\\n     (map vector coll))" "(transpose [1 2 3])" "(transpose matrix1)" "matrix1" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     ;{\:pre [(vector? (first coll))]} \\r\\n     (apply map vector coll))" "(transpose matrix1)" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     (if (vector? (first coll)) \\r\\n     (apply map vector coll))\\n     )" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\n     {\:pre [(float? coll)]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\n       ( map vector coll)\\n       );if\\n  );defn" "(transpose matrix1)" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\n     {\:pre [(not float? coll)]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\n       ( map vector coll)\\n       );if\\n  );defn" "(transpose matrix1)" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\n     {\:pre [(not (float? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\n       ( map vector coll)\\n       );if\\n  );defn" "(transpose matrix1)" "(transpose [1 2 3])" "(transpose matrix1)" "(transpose a)" "(transpose 1)" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\n     {\:pre [(not (float? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\n       ( map vector coll)\\n       );if\\n  );defn" "(transpose 1.1)" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\n     {\:pre [(not (float? coll)) (not (integer? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\n       ( map vector coll)\\n       );if\\n  );defn" "(transpose 1.1)" "(transpose 1)" "(transpose \\"1\\")" "(col-number [1 2 3])" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   }\\n  \\r\\n  \\r\\n\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n(defn Create-laze-Matrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col (rand-int 10)  step (rand-int 10)]\\r\\n    (loop [ result [] row (rand-int 10)]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n(defn Create-laze-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(vector? (first coll))]} \\r\\n     (apply map vector coll))\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  matrix3 matrix3))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  matrix1 ))\\r\\n  \\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n\\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-laze-Matrix-const-size 10 10))\\r\\n)\\n\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   }\\n  )" ";; Switching to MatrixCalculator.core namespace" "(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   }\\n  )\\n  \\r\\n  \\r\\n\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n(defn Create-laze-Matrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col (rand-int 10)  step (rand-int 10)]\\r\\n    (loop [ result [] row (rand-int 10)]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n(defn Create-laze-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(vector? (first coll))]} \\r\\n     (apply map vector coll))\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  matrix3 matrix3))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  matrix1 ))\\r\\n  \\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n\\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-laze-Matrix-const-size 10 10))\\r\\n)\\n\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n     (apply map vector coll)\\n     (map vector coll)\\n     );if\\n   );defn" "(transpose 1)" "(transpose 1.1)" "(transpose \\"1\\")" "(transpose [1 2 3])" "(transpose matrix6)" "(transpose [])" "(doc compare)" "(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n        2 (value-of matrix6 1 1)\\r\\n       )\\r\\n )" "(run-tests)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n     \\n       )\\r\\n )\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n     \\n       )\\r\\n )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n     \\n       )\\r\\n )\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n(clojure.core/ns MatrixCalculator.core)" "(deftest test-power-of\\n  (are [x y] (\= x y)\\n       (run \\"^8\\" matrix3)\\n       ((comp power-of-4 power-of-4)matrix3)\\n       );are\\n  );deftest" "(run-tests)" "(run \\"^8\\" matrix3)" "((comp power-of-4 power-of-4) matrix3)" "(power-of-4 (power-of-4 matrix3))" "(power-of-4 (power-of-4 [[1 1] [1 1]]))" "(power-of-4 [[1 1] [1 1]])" "(deftest test-power-of\\n  (are [x y] (\= x y)\\n       (run \\"^8\\" [[1 1] [1 1]])\\n       ((comp power-of-4 power-of-4) [[1 1] [1 1]])\\n       );are\\n  );deftest" "(run-tests)" "(+ (* 128 128) (* 128 128))" "(deftest test-is-val-not-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n      \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      ) \\r\\n))" "(deftest test-is-val-not-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      ) \\r\\n)" "(run-tests)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"not finding a not existing item in a matrix\\"\\r\\n)\\r\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"not finding a not existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n(defn Create-laze-Matrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col (rand-int 10)  step (rand-int 10)]\\r\\n    (loop [ result [] row (rand-int 10)]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n(defn Create-laze-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  matrix3 matrix3))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  matrix1 ))\\r\\n  \\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n\\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-laze-Matrix-const-size 10 10))\\r\\n)\\n\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   }\\r\\n  )\\n\\n\\r\\n  \\r\\n  \\r\\n\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\r\\n\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"not finding a not existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" "\\n(run-tests 'MatrixCalculator.core-test)" "(\= matrix1 matrix6)" "(defn repeted-row-in-matrix\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\n  [func matrix]\\n (reduce (fn numRank [num] {\:key num \:val 1}) combine) matrix\\n  )" "(defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )" "(defn repeted-row-in-matrix\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\n  [func matrix]\\n (reduce (fn numRank [num] {\:key num \:val 1}) combine) matrix\\n  )" "(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])" "(repeted-row-in-matrix matrix8)" "(defn repeted-row-in-matrix\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\n  [matrix]\\n (reduce (fn numRank [num] {\:key num \:val 1}) combine) matrix\\n  )" "(repeted-row-in-matrix matrix8)" "(clojure.core/ns MatrixCalculator.temp)\\n(defn numRank [num] \\r\\n     {\:key num \:val 1}\\r\\n   )\\r\\n\\r\\n(defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )\\r\\n\\r\\n(defn mapReduce [map-fn reduce-fn  input]\\r\\n     (reduce reduce-fn  {} (map map-fn input))\\r\\n   )\\r\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.temp)\\n(mapReduce numRank combine matrix1)\\n(clojure.core/ns MatrixCalculator.core)" "(mapReduce numRank combine [[1 2 3] [1 2 3] [4 5 6]])" "(clojure.core/ns MatrixCalculator.temp)\\n(mapReduce numRank combine  [[1 2 3] [1 2 3] [4 5 6]])\\n(clojure.core/ns MatrixCalculator.core)" " (reduce reduce-fn  {} (map map-fn input))" " (defn repeted-row-in-matrix\\r\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\r\\n  [matrix]\\r\\n (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  )" "(mapReduce numRank combine [[1 2 3] [1 2 3] [4 5 6]])" "(repeted-row-in-matrix matrix8)" "(doc assoc)" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"not finding a not existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  matrix3 matrix3))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  matrix1 ))\\r\\n  \\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )\\n \\n (defn repeted-row-in-matrix\\r\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\r\\n  [matrix]\\r\\n (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  )\\n\\n (defn positive-numbers\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] (cons n (lazy-seq (positive-numbers (inc n))))))\\n \\n \\n (defn negitive-numbers\\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] (cons n (lazy-seq (negitive-numbers (dec n))))))\\n \\n \\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-laze-Matrix-const-size 10 10))\\r\\n)\\n\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\r\\n   }\\r\\n  )\\n\\n\\r\\n  \\r\\n  \\r\\n\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\r\\n\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  matrix3 matrix3))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  matrix1 ))\\r\\n  \\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )\\n \\n (defn repeted-row-in-matrix\\r\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\r\\n  [matrix]\\r\\n (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  )\\n\\n (defn positive-numbers\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] (cons n (lazy-seq (positive-numbers (inc n))))))\\n \\n \\n (defn negitive-numbers\\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] (cons n (lazy-seq (negitive-numbers (dec n))))))\\n \\n \\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-Matrix-const-size 10 10))\\r\\n)\\n\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\r\\n   }\\r\\n  )\\n\\n\\r\\n  \\r\\n  \\r\\n\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\r\\n\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"not finding a not existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n\\n (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  matrix3 matrix3))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  matrix1 ))\\r\\n  \\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )\\n \\n (defn repeted-row-in-matrix\\r\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\r\\n  [matrix]\\r\\n (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  )\\n\\n (defn positive-numbers\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] (cons n (lazy-seq (positive-numbers (inc n))))))\\n \\n \\n (defn negitive-numbers\\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] (cons n (lazy-seq (negitive-numbers (dec n))))))\\n \\n \\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  [file-name]\\r\\n  (spit file-name (Create-Matrix-const-size 10 10))\\r\\n)\\n\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\r\\n   }\\r\\n  )\\n\\n\\r\\n  \\r\\n  \\r\\n\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\r\\n\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(dot-product [1 2 3] [1 2] )" " (defn dot-product [x y]\\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y)))" "(dot-product [1 2 3] [1 2] )" "(VectorAdd [1 2 3] [1 2 6])" "(VectorAdd [1 2 3] [1 2])" ";; Switching to MatrixCalculator.core namespace" "(row-number [])" "(row-number )" "(row-number empty-matrix)" "(row-number [[] []])" "(first [])" "(first [[] []])" "(col-number [ 1 2 3\\n             ])" "(col-number [[1] [2] [3]])" "(run \\"MA\\" matrix1 matrix6)" "(ShowMatrix (run \\"MA\\" matrix1 matrix6))" "matrix1" "matrix6" "(MatrixSub matrix1 matrix6)" "(run \\"MA\\" matrix1 matrix6)" "(ShowMatrix (run \\"MA\\" matrix1 matrix6))" "(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  mat ))\\r\\n  )" "(ShowMatrix (run \\"MA\\" matrix1 matrix6))" "(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  mat ))\\r\\n  )" "(multy-actions matrix1 matrix6)" "(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\r\\n   }\\r\\n  )\\n" "(ShowMatrix (run \\"MA\\" matrix1 matrix6))" "(defn write-mat-into-file\\r\\n  ([file-name]   (spit file-name (Create-Matrix-const-size 10 10)))\\n  ([file-name mat]  (spit file-name (mat))) \\r\\n\\r\\n)" "(write-mat-into-file \\"mat_A_3_3 \\" matrix3)" "(defn write-mat-into-file\\r\\n  ([file-name]   (spit file-name (Create-Matrix-const-size 10 10)))\\n  ([file-name mat]  (spit file-name mat)) \\r\\n\\r\\n)" "(write-mat-into-file \\"mat_A_3_3 \\" matrix3)" "(defn write-mat-into-file\\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\n  ([file-name mat]  (spit file-name (mat))) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n)" "(clojure.core/ns MatrixCalculator.exampels)\\n(run \\"WMIF\\" \\"mat_A_5_8\\" 5\\n(clojure.core/ns MatrixCalculator.core)" "(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)" "(run \\"WMIF\\" \\"mat_random\\")" "(ns MatrixCalculator.exampels\\n  (\:use [MatrixCalculator.core]) )\\n" "(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)" "(clojure.core/ns MatrixCalculator.core)\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\n   \\"WMIF\\" write-mat-into-file \\r\\n   }\\r\\n  )\\n\\n(clojure.core/ns MatrixCalculator.exampels)" "(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)" "(functions-map \\"dd\\")" "(functions-map dd)" "(defn run\\n  (if (nil? (functions-map f))  (print \\"you've tried to run a function that not exists\\\\n please try again\\")) \\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )" "(defn run\\n  (if (nil? (functions-map f))  (print \\"you've tried to run a function that not exists\\\\n please try again\\") \\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\n  )\\n  \\r\\n                             )" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print \\"you've tried to run a function that not exists\\\\n please try again\\") \\n  )" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print \\"you've tried to run a function that not exists\\\\n please try again\\") )\\n  )" "(check-f 1)" "(check-f nil)" "(check-f (functions-map \\"ff\\"))" "(check-f (functions-map \\"VO\\"))" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map \\"f\\"))  \\n      (print \\"you've tried to run a function that not exists\\\\n please try again\\") )\\n  )" "(check-f (functions-map \\"VO\\"))" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map \\"f\\"))  \\n      (print (functions-map \\"f\\") \\"you've tried to run a function that not exists\\\\n please try again\\") )\\n  )" "(check-f (functions-map \\"VO\\"))" "(check-f (functions-map VO))" "(check-f (functions-map \\"+\\"))" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print (functions-map f) \\"you've tried to run a function that not exists\\\\n please try again\\") )\\n  )" "(check-f (functions-map \\"+\\"))" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print (functions-map f)\\\\n\\"you've tried to run a function that not exists\\\\nplease try again\\") )\\n  )" "(check-f (functions-map \\"+\\"))" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print (functions-map f)\\"\\\\nyou've tried to run a function that not exists\\\\nplease try again\\") )\\n  )" "(check-f (functions-map \\"+\\"))" "(defn run\\r\\n  {\:pre [(nil? (functions-map f))  ]}\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n (defn dot-product [x y]\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  mat ))\\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )\\n \\n (defn repeted-row-in-matrix\\r\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\r\\n  [matrix]\\r\\n (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  )\\n\\n (defn positive-numbers\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] (cons n (lazy-seq (positive-numbers (inc n))))))\\n \\n \\n (defn negitive-numbers\\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] (cons n (lazy-seq (negitive-numbers (dec n))))))\\n \\n \\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name (mat))) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n)\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\n   \\"WMIF\\" write-mat-into-file \\r\\n   }\\r\\n  )\\n\\n\\r\\n  \\r\\n  \\r\\n\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )\\r\\n\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(run \\"dd\\" matrix1)" "(run \\"+\\" matrix1)" "(run \\"+\\" matrix1 matrix2)" "(run \\"+\\" matrix1 matrix1)" "(defn run\\r\\n  {\:pre [(nil? (functions-map f))  ]}\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )" "(functions-map \\"VO\\")" "(functions-map \\"V\\")" "(nil? (functions-map \\"f\\"))" "(functions-map \\"VO\\")" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print (functions-map f)\\"\\\\nyou've tried to run a function that not exists\\\\nplease try again\\") )\\n  )" "(defmacro check-f\\n  [f]\\n    (nil? (functions-map f))  \\n    \\n  )" "(check-f \\"f\\")" "(check-f \\"VO\\")" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print (functions-map f)\\"\\\\nyou've tried to run a function that not exists\\\\nplease try again\\") \\n      1)\\n  )" "(check-f \\"VO\\")" "(defmacro check-f\\n  [f]\\n    (if (nil? (functions-map f))  \\n      (print (functions-map f)\\"\\\\nyou've tried to run a function that not exists\\\\nplease try again\\") \\n      )\\n  )" "(check-f \\"VO\\")" "\\r\\n(defn run\\r\\n  ([f] (check-f f) (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )" "\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (let [func (functions-map f)] (func mat1)     ))  \\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )" "(defmacro check-f\\r\\n     [f]\\r\\n       (if (nil? (functions-map f))  \\r\\n         (print (functions-map f)\\"\\\\nyou've tried to run a function that not exists\\\\nplease try again\\") \\r\\n         )\\r\\n     )" "\\r\\n(defn run\\r\\n  ([f] (let [func (functions-map f)] (func (input) (input))     ))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"you've tried to run a function that not exists\\\\nplease try again\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (let [func (functions-map f)] (func mat1 mat2)     ))  \\r\\n  ([f mat1 mat2 mat3] (let [func (functions-map f)] (func mat1 mat2 mat3)     ))  \\r\\n  ([f mat1 mat2 mat3 mat4] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  ))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) ))\\r\\n                             )" "(run \\"ff\\" matrix1)" "(run \\"ff\\" )" "\\r\\n(defn run\\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func (input) (input))     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\r\\n                             )" "(run \\"ff\\" )" "(run \\"ff\\" map matrix1)" "(value-of matrix1 10 1 )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= \\"AssertionError Assert failed\\")\\r\\n  (value-of matrix1 10 1 )s\\r\\n)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= \\"AssertionError Assert failed\\")\\r\\n  (value-of matrix1 10 1 )\\r\\n)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= (\\"AssertionError Assert failed\\")\\r\\n  (value-of matrix1 10 1 )\\r\\n)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= (\\"AssertionError Assert failed\\")\\r\\n  (value-of matrix1 10 1 )\\r\\n)\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= (\\"AssertionError Assert failed\\"\\r\\n  (value-of matrix1 10 1 ))\\r\\n)\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= (14\\r\\n  (value-of matrix1 10 1 ))\\r\\n)\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is (\=14\\r\\n  (value-of matrix1 10 1 ))\\r\\n)\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is (\= 14)\\r\\n  (value-of matrix1 10 1 )\\r\\n)\\n  )" "(est-value-of)" "(test-value-of)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is (\= nil)\\r\\n  (value-of matrix1 10 1 )\\r\\n)\\n  )" "(test-value-of)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is (\= java.lang.AssertionError\: Assert failed\: (< row (row-number matrix)))\\r\\n  (value-of matrix1 10 1 )\\r\\n)\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is (\= \\"java.lang.AssertionError\: Assert failed\: (< row (row-number matrix)\\"))\\r\\n  (value-of matrix1 10 1 )\\r\\n)\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is (\= \\"java.lang.AssertionError\: Assert failed\: (< row (row-number matrix))\\")\\r\\n  (value-of matrix1 10 1 )\\r\\n)\\n  )" "(test-value-of)" "(try\\r\\n(throw (Exception. \\"something failed\\"))\\r\\n(finally\\r\\n(println \\"we get to clean up\\")))\\r\\n| we get to clean up" "(try \\n  (value-of matrix1 10 1)\\n  \\n  )" "(try \\n  (throw (value-of matrix1 10 1))\\n  (finally (println \\"exception\\"))\\n  )" "(try \\n  (throw (value-of matrix1 10 1)\\n         (value-of matrix1 1 1))\\n  \\n  (finally (println \\"exception\\"))\\n  )" "(try \\n  (throw ;(value-of matrix1 10 1)\\n         (value-of matrix1 1 1))\\n  \\n  (finally (println \\"exception\\"))\\n  )" "(try \\n  (throw (value-of matrix1 10 1))\\n  \\n  (finally (println \\"exception\\"))\\n  )" "(try \\n  ((value-of matrix1 10 1))\\n  \\n  (finally (println \\"exception\\"))\\n  )" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is\= \\"exception\\")\\r\\n  (try ((value-of matrix1 10 1))  (finally (println \\"exception\\")))\\r\\n)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is  (\= \\"exception\\")\\r\\n  (try ((value-of matrix1 10 1))  (finally (println \\"exception\\"))\\r\\n)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is  (\= \\"exception\\")\\r\\n  (try ((value-of matrix1 10 1))  (finally (println \\"exception\\")))\\r\\n)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is  (\= \\"exception\\")\\r\\n  (try ((value-of matrix1 10 1))  (finally (println \\"exception\\")))\\r\\n)\\n  )" "(test-value-of)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is  (\= \\"exception\\")\\r\\n  (try ((value-of matrix1 10 1)) ( java.lang.AssertionError\: Assert failed\: (< row (row-number matrix))) (finally (println \\"exception\\")))\\r\\n)\\n  )" "(try ((value-of matrix1 10 1)) \\r\\n    ( java.lang.AssertionError\: Assert failed\: (< row (row-number matrix))) (finally (println \\"exception\\")))" "(try ((value-of matrix1 10 1)) \\r\\n    ( java.lang.AssertionError) \\n    (finally (println \\"exception\\")))" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n  \\r\\n  (is  (\= \\"exception\\")\\r\\n  (try ((value-of matrix1 10 1)) ( java.lang.AssertionError) (finally (println \\"exception\\")))\\r\\n)\\n  )" "(test-value-of)" "(try ((value-of matrix1 10 1)) \\r\\n    ( java.lang.AssertionError) \\n    (finally (println \\"exception\\")))" "(doc assert)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-wrong-input\\n  (is (\= function not exsists)\\n      (run \\"FNE\\" matrix1 matrix2))\\n  )\\n(clojure.core/ns MatrixCalculator.core)" "\\r\\n(deftest test-wrong-input\\r\\n  (is (\= function not exsists)\\r\\n      (run \\"FNE\\" matrix1 matrix2))\\r\\n  )" "\\r\\n(deftest test-wrong-input\\r\\n  (is (\= \\"function not exsists\\")\\r\\n      (run \\"FNE\\" matrix1 matrix2))\\r\\n  )" "(test-wrong-input)" "(run-tests)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\n \\r\\n)\\n(clojure.core/ns MatrixCalculator.core)" "(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)" "(run-tests)" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= function not exsists)\\n      (run \\"FNE\\" matrix1 matrix2))\\n  )\\n\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" "(run-tests)" "(test-MatrixSub)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n(clojure.core/ns MatrixCalculator.core)" "(test-MatrixSub)" "(test-wrong-input)" "(test-wrong-dot)" "(test-dot-product)" "(doc \:pre)" "(doc AssertionError)" "(doc java.lang.AssertionError)" "(class java.lang\\n       )" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]])\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new random matrix\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n   \\n (defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n     (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix)\\r\\n    \\"Wrong input\\") \\r\\n   )\\n\\n \\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  \\r\\n  )\\n \\n (defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix)\\r\\n       \\"Wrong input\\") \\r\\n      )\\n \\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n (defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true)\\n      );do\\r\\n    );if\\n   )\\n\\n \\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\n      )\\r\\n     \\n (defn dot-product [x y]\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y)))\\n \\n \\n  (defn VectorAdd\\r\\n        \\"return the sum of two vectors\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        )\\n \\n  (defn VectorSub\\r\\n        \\"return the submition of two vectors\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub)\\r\\n        )\\n \\n(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )\\r\\n     \\n \\n \\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )\\n \\n \\n\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n     ([] 0) \\r\\n     ([mat] (if (vector? (first mat))\\n       (count mat) 1)\\n            );if\\r\\n     );defn\\n \\n (defn col-number \\r\\n     \\"return the number of col's in a matrix\\"\\r\\n     [mat] ((comp count transpose )mat) \\r\\n     )\\n \\n \\n \\n (defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n (defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn\\n \\n\\r\\n(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))\\n \\n (defn index-of-cells [f mat1 mat2 ]\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\r\\n\\n \\n \\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))\\n \\n\\n\\n\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose)  mat ))\\r\\n  )\\n\\n\\n (defn power-of-4\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n     )\\n\\n \\n (defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       )\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1)\\r\\n               )\\r\\n     )    \\r\\n   )\\n \\n (defn repeted-row-in-matrix\\r\\n  \\"check whether a row is repeated in the matrix and if so how many times\\"\\r\\n  [matrix]\\r\\n (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  )\\n\\n (defn positive-numbers\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] (cons n (lazy-seq (positive-numbers (inc n))))))\\n \\n \\n (defn negitive-numbers\\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] (cons n (lazy-seq (negitive-numbers (dec n))))))\\n \\n \\n(defmacro input\\n  \\"macro that reads the input matrix.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  )\\n\\n(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\n(defmacro input2\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )\\n\\r\\n\\n(defn write-mat-into-file\\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name (mat))) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n)\\n\\n(defn run-from-file\\r\\n[file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)]\\r\\n        ( func mat1 mat2) )\\r\\n)\\n\\n(def functions-map\\r\\n  {\\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"CM\\" CreateMatrix\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\n   \\"RRIM\\" repeted-row-in-matrix\\n   \\"WMIF\\" write-mat-into-file \\r\\n   }\\r\\n  )\\n\\n\\r\\n  \\r\\n(defn run\\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func (input) (input))     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\r\\n                             )\\n\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= function not exsists)\\n      (run \\"FNE\\" matrix1 matrix2))\\n  )\\n\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\")\\n      (run \\"FNE\\" matrix1 matrix2))\\n  )\\n\\n\\n\\n\\n(clojure.core/ns MatrixCalculator.core)" "(run-tests)" "(run-tests 'MatrixCalculator.core-test)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\") (run \\"FNE\\" matrix1 matrix2))\\n  (is (\= \\"wrong input\\") (run \\"+\\" matrix2 matrix3))\\n  )\\n(clojure.core/ns MatrixCalculator.core)" "(run-tests 'MatrixCalculator.core-test)" "(transpose 2)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\") (run \\"FNE\\" matrix1 matrix2))\\n  (is (\= \\"Wrong input\\") (run \\"+\\" matrix1 matrix3))\\n  (is (\= false ) (CheckMatrix matrix2))\\n  )\\n\\n(clojure.core/ns MatrixCalculator.core)" "(run-tests 'MatrixCalculator.core-test)" "(def functions-map\\r\\n  {\\"CM\\" CreateMatrix\\n   \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\n   \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\n   \\"CMCS\\" Create-Matrix-const-size\\n   \\"+\\" MatrixAdd \\r\\n   \\"++\\" super-MatrixAdd\\r\\n   \\"-\\" MatrixSub\\r\\n   \\"*\\" MatrixMult\\r\\n   \\"^4\\" power-of-4\\r\\n   \\"^8\\" power-of-8\\r\\n   \\"t\\" transpose\\r\\n   \\"DP\\" dot-product\\r\\n   \\"VA\\" VectorAdd\\r\\n   \\"VS\\" VectorSub\\r\\n   \\"RN\\" row-number\\r\\n   \\"CN\\" col-number \\r\\n   \\"MVM\\" mult-vec-mat\\r\\n   \\"VO\\" value-of\\r\\n   \\"IOC\\" index-of-cells\\r\\n   \\"IVEIM\\" is-val-exsist-in-mat\\r\\n   \\"MA\\" multy-actions\\r\\n   \\"RRIM\\" repeted-row-in-matrix\\r\\n   \\"WMIF\\" write-mat-into-file \\r\\n   }\\r\\n  )" "(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])" "(run \\"CLPM\\")" "(functions-map \\"CLPM\\")" "(run \\"CLPM\\")" "(Create-lazy-positiveNumbers-Matrix)" "(defn run\\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\r\\n                             )" "(run \\"CLPM\\")" "(run \\"CLNM\\")" "(run \\"t\\" matrix1)" "(ShowMatrix(run \\"t\\" matrix1))" "(matrix1)" "matrix1" "matrix1 (ShowMatrix(run \\"t\\" matrix1))" "(ShowMatrix matrix1) (ShowMatrix(run \\"t\\" matrix1))" "(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (map (fn [vec] (println vec) ) mat))\\r\\n     )" "(ShowMatrix matrix1) (ShowMatrix(run \\"t\\" matrix1))" "(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (print vec \\"\\\\n\\") ) mat))\\r\\n     )" "(ShowMatrix matrix1) (ShowMatrix(run \\"t\\" matrix1))" "(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (map (fn [vec] (println vec) ) mat))\\r\\n     )" "(defn ShowMatrix \\r\\n     \\"print the matrix\\"\\r\\n     ;([mat1 mat2] (print \\"you've entered 2 matrix\\")) \\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     )" "(run \\"SM\\" matrix1)" "(def functions-map\\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"MVM\\" mult-vec-mat\\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\r\\n      \\"WMIF\\" write-mat-into-file \\r\\n      }\\r\\n     )" "(run \\"SM\\" matrix1)" "(run \\"SH\\" \\"+\\" matrix1 matrix1)" "(run \\"SH\\" \\"t\\" matrix1)" "(defn run\\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\r\\n                             )" "(run \\"SH\\" \\"t\\" matrix1)" "(run \\"SH\\" (run\\"t\\" matrix1))" "(run \\"SH\\" (run \\"t\\" matrix1))" "(run \\"t\\" matrix1)" "(run \\"SM\\" (run \\"t\\" matrix1))" "(run \\"SM\\" \\"t\\" matrix1)" "(clojure.core/ns MatrixCalculator.exampels)\\n(run \\"SH\\" (run \\"++\\" (CreateMatrix) (CreateMatrix)))\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(run \\"SM\\" (run \\"++\\" (CreateMatrix) (CreateMatrix)))\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(run \\"++\\" (CreateMatrix) (CreateMatrix))\\n(clojure.core/ns MatrixCalculator.core)" "(run \\"SM\\" (run \\"++\\" (CreateMatrix) (CreateMatrix)))" "(run \\"SM\\" (run \\"+\\" (Create-Matrix-const-size 10 10) (Create-Matrix-const-size 10 10)))" "(run \\"RRIM\\" (run \\"CLPM\\"))" "((comp run run) \\"PRIM\\" \\"CLPM\\")" "(clojure.core/ns MatrixCalculator.exampels)\\n(run \\"RRIM\\" (run \\"t\\" (run \\"CLPM\\")))\\n(clojure.core/ns MatrixCalculator.core)" "(run \\"RRIM\\" (run \\"t\\" (run \\"CLPM\\")))" "(run \\"+\\" matrix2 matrix2)" "(run \\"-\\" matrix2 matrix2)" "(run \\"++\\" matrix2 matrix2)" "(doc *load-tests*)" "(*load-tests* \= false)" "(*load-tests* \= 'false)" "(load-tests \= false)" "(*load-tests* \= FALSE)" "(*load-tests* \= \\"false\\n\\")" "(def *load-tests* false)" "(*load-tests* \= false)" "(clojure.core/ns examples.testing.people-data)\\n(def people [\\n             {\:name \\"Joe\\" \:id 12}\\n              {\:name \\"Tom\\" \:id 15}\\n               {\:name \\"Jane\\" \:id 25}\\n               {\:name \\"James\\" \:id 45}\\n               {\:name \\"Frank\\" \:id 65}\\n                {\:name \\"Ethel\\" \:id 77}\\n                {\:name \\"John\\" \:id 87}\\n                 {\:name \\"Lamar\\" \:id 97}\\n             ])\\n\\n(defn op-people [op p1 p2]\\n  {\:pre [(contains? p1 \:id ) (contains? p2 \:id ) (number? (\:id p1)) (number? (\:id p2))]\\n   \:post [(or (\= true %) (\= false %))]\\n   }\\n ;(println p1 p2)\\n  (op (\:id p1) (\:id p2))  \\n)\\n\\n(defn gt-people[p1 p2] (op-people > p1 p2))\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns examples.testing.people-data)\\n;(println p1 p2)\\n  (op (\:id p1) (\:id p2))  \\n(clojure.core/ns MatrixCalculator.core)" "  (op (\:id p1) (\:id p2))  \\r\\n)" "(defn gt-people[p1 p2] (op-people > p1 p2))" "(defn op-people [op p1 p2]\\r\\n  {\:pre [(contains? p1 \:id ) (contains? p2 \:id ) (number? (\:id p1)) (number? (\:id p2))]\\r\\n   \:post [(or (\= true %) (\= false %))]\\r\\n   }\\r\\n ;(println p1 p2)\\r\\n  (op (\:id p1) (\:id p2))  \\r\\n)" "(defn gt-people[p1 p2] (op-people > p1 p2))" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn" "(transpose matrix2)" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(CheckMatrix coll) (not (integer? coll))(not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn" "(transpose matrix2)" "(transpose matrix1)" "(CheckMatrix 1)" "(CheckMatrix [1])" "(CheckMatrix [1 2 3])" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      true)\\r\\n      )" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n      (if-not (vector? (first mat)) false true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )\\r\\n      )" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      )" "(CheckMatrix [1 2 3])" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\n  (if (col-number 1) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(CheckMatrix [1 2 3])" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\n  (if (\= col-number 1) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(CheckMatrix [1 2 3])" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\n  (if (\= (col-number mat) 1) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(CheckMatrix [1 2 3])" "(\= (col-number [1 2 3]) 1)" "(col-number [1 23 3])" "(transpose [1 2 3])" "(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll))(not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n " "(transpose [1 2 3])" "(col-number [1 23 3])" "(\= (col-number [1 2 3]) 1)" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\n  (if (\= (row-number-number mat) 1) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\n  (if (\= (row-number mat) 1) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(CheckMatrix [1 2 3])" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'MatrixCalculator.core)))" "(run \\"SM\\" (run \\"t\\" matrix1))" "\\n(defn multy-actions \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  )" "(multy-actions matrix1)" "(MatrixAdd [1 2 3] [1 2 3])" "(doc mapv)" "(doc assoc)" "(doc map)" "(doc ->)" "(doc symbol)" "(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp INPUT/file-name))\\r\\n  )" "(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp \\"INPUT\\"/file-name))\\r\\n  )" "(defmacro input1\\r\\n  \\"macro that reads the input matrix.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  )" "(input1 \\"matrix1\\")" "(input1 \\"matrix1.txt\\")" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n   (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );defn" "(MatrixMult [1 2 3] [1 2 3])" "\\r\\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (count mat2) (count(transpose mat1)))\\r\\n  )" "(count [1 2 3])" "(count (transpose[1 2 3]))" "\\r\\n (defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  )" "(MatrixMult [1 2 3] [1 2 3])" "(CheckMultiply [1 2 3] [[1] [2] [3]])" "(CheckMultiply [[1] [2] [3]] [1 2 3])" "(defn CheckMultiply \\r\\n  \\"checks that the number of col's of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  )\\n " "(MatrixMult [[1] [2] [3]] [1 2 3])" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (col-number mat1) 1) (dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (col-number mat1) 1) (print \\"hello\\" ;(dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (col-number mat1) 1) (print \\"hello\\") ;(dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (col-number mat1) 1) (dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (print \\"hello\\") ;(dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(dot-product [1 2 3] [[1] [2] [3]])" "(row-number [[1] [2] [3]])" " (defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y)))" "(row-number [[1] [2] [3]])" "(dot-product [1 2 3] [[1] [2] [3]])" "(col-number [1 2 3])" "(col-number [[1] [2] [3]])" "(dot-product [1 2 3] [1 2 3])" "(dot-product [1 2 3] [1 2])" "(dot-product [1 2 3] [])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y))\\n     sdg)" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             ]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] y)]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [])" "(\= (col-number [1 2 3]) (col-number [[1] [2] [3]]))" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (not\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (not\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(not\= [] [1 2 3])" "(MatrixMult matrix3 matrix3)" "(MatrixMult matrix3 matrix2\\n            )" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     \\n      (print x y)\\n      (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) \\r\\n             (\= 1 (row-number x)) (\= 1 (row-number y))\\r\\n             (\= (col-number x) (col-number y))]}   \\r\\n     \\n      (print (\= (col-number x) (col-number y)))\\n      (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y))]}   \\n      (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\n      (reduce + (pmap * x y)) (print \\"wrong input\\"))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)))]}   \\n      (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      {\:pre [(or (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)))]}   \\n      (reduce + (pmap * x y))\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 mat2) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(dot-product [1 2 3] [[1] [2] [3]])" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input\\"))\\r\\n     )" "(dot-product [1 2 3] [[1] [2] [3]])" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten)mat2)) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  {\:pre [(> row1 0) (> col1 0)]}\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n   );defn" "(Create-Matrix-const-size -1 2)" "(Create-Matrix-const-size (-1) 2)" "(Create-Matrix-const-size -1 -2)" "(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\n  );if\\r\\n   );defn" "(Create-Matrix-const-size -1 -2)" "(transpose 3)" "(Check_addition [1 2 3] [1 2 3])" "(MatrixAdd [] [])" "(MatrixSub [] [])" "(MatrixMult [] [])" "(transpose [])" "(value-of matrix1 4 19)" "(value-of matrix1 14 19)" "(value-of matrix1 1 19)" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  {\:pre [(CheckMatrix mat1) (CheckMatrix mat2)]}\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))" "(index-of-cells \= matrix2 matrix1)" "\\n\\n(run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_B_10_10\\"))" "(run \\"SM\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_B_10_10\\"))" "(run \\"SM\\"(input1 \\"mat_B_10_10\\"))" "(run \\"SM\\"(input1 \\"mat_A_10_10\\"))" "\\n\\n(run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))" "\\r\\n(deftest test-is-value-of\\r\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\r\\n  )" "(test-is-value-of)" "(clojure.core/ns MatrixCalculator.core-test)\\n(deftest test-is-value-of\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\n  )\\n(clojure.core/ns MatrixCalculator.core)" "(test-is-value-of)" "\\r\\n\\r\\n(deftest test-is-value-of\\r\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\r\\n  )" "(test-is-value-of)" "(run-all-tests)" "(clojure.core/ns MatrixCalculator.core-test)\\n(run-tests)\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               (Create-laze-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n; (time(lazy-value-of-mult \\r\\n;     (Create-laze-Matrix-const-size 100 100) \\r\\n;     (Create-laze-Matrix-const-size 100 100)\\r\\n;     5 9))\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\") (run \\"FNE\\" matrix1 matrix2))\\n  (is (\= \\"Wrong input\\") (run \\"+\\" matrix1 matrix3))\\n  (is (\= false ) (CheckMatrix matrix2))\\n  )\\n\\n\\n(deftest test-is-value-of\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\n  )\\n\\n(run-tests)\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.core-test)\\n(run-tests)\\n(clojure.core/ns MatrixCalculator.core)" "(dot-product matrix1 matrix1)" "(row-number 8)" "(count 9)" "(row-number [])" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      {\:pre [(vector? mat)]} \\r\\n     ([mat] (if (vector? (first mat))\\r\\n       (count mat) 1)\\r\\n            );if\\r\\n     );defn" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\n     {\:pre [(vector? mat)]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number [])" "(count 9)" "(vector? 9)" "(row-number [1])" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\n     {\:pre [(vector? mat)]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number 8)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\n     {\:pre [(vector? mat) (nil? (first mat))]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number [])" "(nil? (first []))" "(row-number matrix1)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\n     {\:pre [(vector? mat) (not\= (first mat) nil)]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number [])" "(col-number matrix2)" "\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn\\n " "a" "(a)" "(col-number matrix2)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(col-number matrix2)" "(col-number matrix1)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(col-number matrix1)" "(CheckMatrix matrix2)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(col-number matrix2)" "(row-number matrix1)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil)]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n  (if (\= (count mat) 1) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number matrix1)" "(col-number matrix2)" "(row-number matrix2)" "(CheckMatrix matrix2)" "(defn col-number \\r\\n     \\"return the number of col's in a matrix\\" \\n     [mat] \\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\n     ((comp count transpose )mat) \\r\\n     );defn" "(col-number [])" "(col-number matrix2)" "(col-number matrix1)" "(col-number [1 2 3])" "(row-number [1 2 3])" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number [1 2 3])" "(vector? (first [1 2 3]))" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n  (if (or (\= (count mat) 1) (\= (count (transpose mat)) 1) ) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(row-number [1 2 3])" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number [1 2 3])" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(row-number [1 2 3])" "(count (transpose [1 2 3]))" "(transpose [[1] [2] [3]])" "(not (vector? (first [1 2 3])))" "(not (vector? (first [1])))" "(not (vector? (first [])))" "(not (vector? (first 2)))" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n  (if (or (\= (count mat) 1) (\= (count (transpose mat)) 1)  (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(CheckMatrix [])" "(CheckMatrix 3)" "(defn CheckMatrix [mat]\\r\\n  \\"cheks that all dimentuons are equal.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))))\\r\\n      );if-not\\r\\n      )" "(CheckMatrix 3)" "(CheckMatrix [])" "(CheckMatrix [1 2 3])" "(CheckMatrix [[1] [2] [3]])" "(row-number [1 2 3])" "(row-number [[1] [2] [2]])" "(col-number [[1] [2] [2]])" "(col-number [1 2 3])" "(col-number [])" "(col-number 9)" "(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn" "(defn col-number \\r\\n     \\"return the number of col's in a matrix\\" \\n     [mat] \\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\n     ((comp count transpose )mat) \\r\\n     );defn" "(row-number matrix2)" "(col-number matrix2)" "(MatrixMult matrix3 [1 2 3])" "(MatrixMult [1 2 3] matrix3)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (mult-vec-mat mat1 mat2) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) )\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn" "(MatrixMult [1 2 3] matrix3)" "matrix3" "(MatrixMult [1 2 3] [[1] [2] [3]])" "(MatrixMult [[1] [2] [3]] [1 2 3])" "(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))" "\\n\\n(run \\"IOC\\" > (input1 \\"mat_A_10_10\\") (input1 \\"mat_B_10_10\\"))" "\\n\\n(run \\"IOC\\" > (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))" "(deftest test-index-of-cell\\r\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\r\\n   (is (\= ())\\r\\n        (run \\"IOC\\" > (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       )\\r\\n  )" "(clojure.core/ns MatrixCalculator.core-test)\\n(run-tests)\\n(clojure.core/ns MatrixCalculator.core)" "(test-index-of-cell)" "(defn value-of \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col))" "(value-of matrix2 1 2)" "(value-of matrix1 1 2)" "(value-of matrix1 1 21)" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))" "(run \\"IVEIM\\" matrix2 1)" "(run \\"IVEIM\\" matrix3 1)" "(run \\"IVEIM\\" matrix3 405)" "(run \\"IVEIM\\" matrix3 s)" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1) (not (string? value))]}\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))" "(run \\"IVEIM\\" matrix3 s)" "(run \\"IVEIM\\" matrix3 405)" "(run \\"IVEIM\\" matrix3 \\"u\\")" "(run \\"IVEIM\\" matrix3 functions-map)" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the matrix,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} )\\r\\n))" "(symbol? a)" " (defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\n     (print \\"input must be quadratic matrix\\") ) \\r\\n     )" " (defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\n     (print \\"input must be quadratic matrix\\") ) \\r\\n     )" "(run \\"^4\\" matrix3)" "(run \\"^4\\" matrix1)" "(multy-actions matrix2)" "(multy-actions matrix1)" "(multy-actions matrix1 matrix1)" "(multy-actions matrix1 matrix3)" "(multy-actions [1 2 3 4])" "(multy-actions [[1] [2]])" "(multy-actions [[1]])" "(repeted-row-in-matrix [1 2 3])" "(repeted-row-in-matrix [\\n                        ])" "(repeted-row-in-matrix matrix2)" "(run \\"WMIF\\" \\"vector\\" (vector (flatten (run \\"CM\\"))))" "(run \\"CM\\")" "(run \\"WMIF\\" \\"vector\\" (vector (flatten (run \\"CM\\"))))" "(flatten (run \\"CM\\"))" "(vector (flatten (run \\"CM\\")))" "(run \\"WMIF\\" \\"vector\\" (vector (flatten (run \\"CM\\"))))" "(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))" "(vec (flatten (run \\"CM\\")))" "(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))" "(write-mat-into-file \\"vector\\" (vec (flatten (run \\"CM\\"))))" "(run \\"WMIF\\" \\"vector\\" [1 2 3])" "(run \\"WMIF\\" \\"vector\\" matrix1)" "(write-mat-into-file \\"vector\\" [1 2 3])" "(write-mat-into-file \\"vector\\" matrix1)" "(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)" "(write-mat-into-file \\"vector_A\\" matrix1)" "(write-mat-into-file \\"vector_A\\" )" "(write-mat-into-file \\"vector\\" )" "(write-mat-into-file \\"vector\\" matrix1)" "(defn write-mat-into-file\\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n)" "(write-mat-into-file \\"vector\\" matrix1)" "\\n(write-mat-into-file \\"vector\\" (vec (flatten (run \\"CM\\"))))" "\\n\\n(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))" "\\n(write-mat-into-file \\"vector\\" (vec (flatten (run \\"CM\\"))))" "\\n\\n(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))" "(vec (flatten (run \\"CM\\")))" "\\n\\n(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))" "\\n\\n(run \\"WMIF\\" \\"vector\\" ((vec (flatten (run \\"CM\\")))))" "\\n\\n(run \\"WMIF\\" \\"vector\\" (vector (flatten (run \\"CM\\"))))" "\\n\\n(run \\"WMIF\\" \\"vector\\" [1 2 3])" "\\n\\n(run \\"WMIF\\" \\"vector\\" matrix1)" "(run \\"WMIF\\" \\"mat_random\\")" "(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)" "(run \\"WMIF\\" \\"vector\\" 5 8)" "(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)" "(run \\"WMIF\\" \\"mat_random\\" [1 2 3])" "(spit \\"vector\\" matrix1)" "(spit \\"vector\\" [1 2 3])" "(defn write-mat-into-file\\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n)" "(run \\"WMIF\\" \\"mat_random\\" [1 2 3])" "(write-mat-into-file \\"WMIF\\" \\"mat_random\\" [1 2 3])" "(write-mat-into-file \\"vector\\" [1 2 3])" "(run \\"WMIF\\" \\"vector\\" [1 2 3])" "(run \\"WMIF\\" \\"vector\\" matrix1)" "(spit file-name matrix1)" "(spit \\"vector\\" matrix1)" "(def functions-map\\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )" "(run \\"WMIF\\" \\"vector\\" matrix1)" "(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  {\:pre [(CheckMatrix mat1) (CheckMatrix mat2)]}\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))" "(run \\"IOC\\" MatrixAdd matrix1 matrix1)" "(run \\"IOC\\" count matrix1 matrix1)" "(run \\"IOC\\" (count) matrix1 matrix1)" "(run \\"IOC\\" - matrix1 matrix1)" "(run \\"IOC\\" false matrix1 matrix1)" "(run \\"IOC\\" is matrix1 matrix1)" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2)]}\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n           \:when (f x y) ] \\r\\n  {\:r row \:c col} )\\r\\n))" "(run \\"IOC\\" is matrix1 matrix1)" "(run \\"IOC\\" d matrix1 matrix1)" "(run \\"IOC\\" do matrix1 matrix1)" "(run \\"IOC\\" \\"h\\" matrix1 matrix1)" "(\= (IndexOutOfBoundsException) (value-of  matrix1 3 19))" "(defn run-from-file\\r\\n  \\"this function gets a file name that consist of a function name\\r\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\r\\n  ) ;2 arguments\\r\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\r\\n        );let\\r\\n  );3 arguments\\r\\n );defn" "(doc negitive-numbers)" "\\n(negitive-numbers -3)" "\\n(negitive-numbers \\n  )" "(take 10 (negitive-numbers -2))" "(take 10 (negitive-numbers 6))" "(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negative numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn" "(take 10 (negitive-numbers 6))" "(defn positive-numbers\\r\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\r\\n    );defn" "(deftest test-check \\r\\n  (is (\= false)\\r\\n      (CheckMatrix matrix2))\\r\\n  )" "(deftest test-check \\r\\n  (is (\= false)\\r\\n      (CheckMatrix matrix2)\\n      (CheckMultiply matrix1 matrix7) )\\r\\n  )" "(deftest test-check \\r\\n  (are [x y] (\= x y)\\r\\n     false (CheckMatrix matrix2)\\n     true  (CheckMatrix matrix3)\\n     false (CheckMultiply matrix1 matrix7)\\n     true  (CheckMultiply matrix1 matrix3)\\n     false (Check_addition matrix1 matrix3)\\n     true  (Check_addition matrix3 matrix3)\\n      )\\r\\n  )" "(clojure.core/ns MatrixCalculator.core-test)\\n(run-tests)\\n(clojure.core/ns MatrixCalculator.core)" "(MatrixAdd [1 2 3] [1 2 3])" "\\r\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n    (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\");if \\r\\n    );if\\r\\n   );defn" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n    (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\r\\n    );if\\r\\n    );\\r\\n   );defn" "(transpose \\"r\\")" "(transpose (1 2 3))" "(list? (1 2 3))" "(MatrixMult matrix3 matrix1)" "(run \\"*\\" matrix3 matrix1)" "(index-of-cells \= [1 2 3] [1 2 3])" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_additions mat1 mat2)]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(index-of-cells \= matrix1 matrix8)" "(Check_addition matrix1 matrix8)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n    (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\n    );if\\n    );\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input\\"));if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\r\\n     ((comp count transpose )mat) \\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\n  \\"gets 2 matrix and return the product of the two matrix.\\" \\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn\\n\\n\\n\\r\\n(defn value-of \\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n  ((matrix row) col)\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (count mat1) cols (count (mat1 0))]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\n);defn\\n\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(index-of-cells matrix1 matrix8)" "(index-of-cells \= matrix1 matrix8)" "\\r\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (true)]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(index-of-cells \= matrix1 matrix8)" "\\r\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) ]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(index-of-cells \= matrix1 matrix2)" "(index-of-cells \= matrix1 matrix8)" "(index-of-cells \= matrix2 matrix2)" "\\r\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(Check_addition mat1 mat2) (CheckMatrix mat1) (CheckMatrix mat2) ]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(index-of-cells \= matrix2 matrix2)" "(index-of-cells \= matrix1 matrix8)" "(value-of [1 2 3] 0 1)" "(value-of [1 2 3] 0 0)" "(value-of [1 2 3] 1 1)" "(value-of [1 2 3] 0 0)" "(([1 2 3] 0) 0)" "(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\n     );if\\r\\n  );defn" "([1 2 3] 0)" "(value-of [1 2 3] 0 0)" "(index-of-cells \= matrix1 matrix8)" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)]}\\r\\n     (let [rows (count mat1) cols (count (mat1 0))]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn\\n " "(index-of-cells \= matrix1 matrix8)" "(index-of-cells \= [1 2 3] [1 2 3\\n                           ])" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)]}\\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     {\:pre [(function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)]}\\r\\n     (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n  );defn" "(index-of-cells \= [1 2 3] [1 2 3\\n                           ])" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2))\\n      (print \\"wrong input\\") \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\n     );if\\r\\n  );defn" "(index-of-cells \= matrix1 matrix8)" "matrix1" "matrix8" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (or (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2))\\n      (print \\"wrong input\\") \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\n     );if\\r\\n  );defn" "(index-of-cells \= matrix1 matrix8)" "(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\n     (print \\"wrong input\\") );if\\r\\n  );defn" "(index-of-cells \= matrix1 matrix8)" "(index-of-cells \= [1 2 3] [1 2 3])" "(index-of-cells \= matrix2 matrix8)" "(index-of-cells \= matrix2 matrix3)" "(index-of-cells \= matrix3 matrix3)" "(run \\"IVEIM\\" [1 2 3] 3)" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn" "(run \\"IVEIM\\" [1 2 3] 3)" "(run \\"IVEIM\\" [1 2 3] 1)" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn" "(run \\"IVEIM\\" [1 2 3] 1)" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn" "(run \\"IVEIM\\" [1 2 3] 1)" "(run \\"IVEIM\\" [1 2 3] 5)" "(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n" "(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn" "(run \\"IVEIM\\" [1 2 3] 5)" "(run \\"MA\\" matrix3 matrix1)" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n    (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\n    );if\\n    );\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input\\"));if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\r\\n     ((comp count transpose )mat) \\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\n  \\"gets 2 matrix and return the product of the two matrix.\\" \\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn\\n\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     (print \\"wrong input \\") );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\n    );if\\n    ;);\\r\\n   );defn" "\\r\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\r\\n    );if\\r\\n    ;);\\r\\n   );defn" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\n    );if\\n    ;);\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input\\"));if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\r\\n     ((comp count transpose )mat) \\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\n  \\"gets 2 matrix and return the product of the two matrix.\\" \\r\\n  {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn\\n\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     (print \\"wrong input \\") );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(run \\"MA\\" matrix3 matrix1)" "(defn multy-actions \\r\\n  \\"preform few actions on a given input.\\r\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\r\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\r\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub )  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn" "(run \\"MA\\" matrix3 matrix1)" "(MatrixAdd matrix3 matrix1)" "(MatrixSub matrix3 matrix1)" "(MatrixMult matrix3 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\" \\r\\n ; {\:pre [(CheckMultiply mat1 mat2) ]}  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn" "(MatrixMult matrix3 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\" \\r\\n  (if (CheckMultiply mat1 mat2)   \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\n (print \\"wrong input\\") )\\r\\n  );defn" "(MatrixMult matrix3 matrix1)" "(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n" "(run \\"MA\\" matrix1 matrix3)" "(multy-actions matrix1 matrix3)" "(MatrixMult matrix1 matrix3)" "(MatrixMult matrix3 matrix1)" "(CheckMultiply matrix3 matrix1)" "(MatrixMult matrix1 matrix1)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\n    );if\\n    ;);\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input\\"));if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\r\\n     ((comp count transpose )mat) \\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn\\n\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     (print \\"wrong input \\") );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(multy-actions matrix1 matrix3)" "(multy-actions matrix3 matrix1)" "(doc \:pre)" "(doc pre)" "(MatrixMult matrix1 matrix3)" "(MatrixMult matrix3 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn" "(CheckMultiply matrix3 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\n  {\:pre [(CheckMultiply mat1 mat2)]} \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn" "(CheckMultiply matrix3 matrix1)" "(MatrixMult matrix3 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\n  (print \\"wrong input\\"));if\\r\\n  );defn" "(MatrixMult matrix3 matrix1)" "(multy-actions matrix3 matrix1)" "(multy-actions matrix1 matrix3)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input\\"\\n    );if\\n    ;);\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input\\"));if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ]} \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     {\:pre [(vector? mat) (not\= (first mat) nil) (CheckMatrix mat)]}\\r\\n     ((comp count transpose )mat) \\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn\\n\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     (print \\"wrong input \\") );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(multy-actions matrix1 matrix1)" "(MatrixMult matrix1 matrix1)" "(CheckMultiply matrix1 matrix1)" "(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     (print \\"wrong input col-number\\") );if\\r\\n     )" "(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\r\\n     (print \\"wrong input col-number\\") );if\\r\\n     );defn" "\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n      (print \\"wrong input row-number\\"));if\\r\\n     );defn\\n" "\\r\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\r\\n      (print \\"wrong input row-number\\"));if\\r\\n     );defn" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input MatrixAdd\\"\\n    );if\\n    ;);\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input MatrixSub\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) (print \\"wrong input dot-product\\"));if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n      (print \\"wrong input row-number\\"));if\\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     (print \\"wrong input col-number\\") );if\\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn\\n\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     (print \\"wrong input index-of-cells\\") );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(MatrixSub matrix1 matrix1)" "(MatrixMult matrix1 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (\= (row-number mat1) 1) (mult-vec-mat mat1 mat2) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );defn" "(MatrixMult matrix1 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1) (dot-product mat1 (vec (flatten mat2))) \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  (print \\"wrong input\\"));if\\r\\n  );defn" "(MatrixMult matrix1 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  (print \\"wrong input\\"));if\\r\\n  );defn" "(MatrixMult matrix1 matrix1)" "(MatrixMult matrix3 matrix1)" "(MatrixMult matrix1 matrix3)" "(multy-actions matrix1 matrix3)" "(multy-actions matrix1 matrix1)" "(multy-actions matrix3 matrix1)" "(MatrixMult matrix3 matrix1)" "(multy-actions matrix1 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  (print \\"wrong input MatrixMult\\"));if\\r\\n  );defn" "(multy-actions matrix1 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (not(CheckMultiply mat1 mat2)) (print \\"wrong input MatrixMult\\")\\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  );if\\r\\n  );defn" "(multy-actions matrix1 matrix1)" "(MatrixMult matrix1 matrix1)" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  )" "(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  );defn" "(MatrixMult matrix1 matrix1)" "(multy-actions matrix1 matrix1)" "(multy-actions matrix2)" "(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     (\\"wrong input col-number \\") );if\\r\\n     );defn" "(multy-actions matrix2)" "(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     \\"wrong input col-number \\" );if\\r\\n     );defn" "(multy-actions matrix2)" "(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) \\"wrong input dot-product \\");if\\r\\n     );defn" "(power-of-4 matrix3)" "(power-of-4 matrix1)" "(power-of-4 matrix2)" "(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat]\\r\\n     (if (\= (row-number mat) (col-number mat)) \\r\\n     ((def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)))\\r\\n     (print \\"input must be quadratic matrix\\") );if \\r\\n     );defn" "(power-of-4 matrix3)" "(power-of-8 matrix3)" "(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat] \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)) \\r\\n     );defn" "(power-of-4 matrix3)" "(power-of-4 matrix2)" "(power-of-8 matrix2)" "(power-of-1 matrix1)" "(power-of-4 matrix1)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ; (if (row-number mat1) (VectorAdd mat1 mat2) \\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input MatrixAdd\\"\\n    );if\\n    ;);\\r\\n   );defn\\n\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n        (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input MatrixSub\\");if \\r\\n      );defn\\n\\t\\n\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) \\"wrong input dot-product \\");if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n       \\"wrong input row-number\\");if\\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     \\"wrong input col-number \\" );if\\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  );defn\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     \\"wrong input index-of-cells\\" );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat] \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)) \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(power-of-8 matrix3)" "(power-of-8 matrix1)" "(power-of-8 matrix2)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n    );if\\r\\n   );defn" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    ((let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input MatrixAdd\\")\\r\\n    );if\\r\\n    );if\\r\\n   );defn" "(MatrixAdd [1 2 3] [1 2 3])" "\\r\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (row-number mat1) (VectorSub mat1 mat2) \\n       ((let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input MatrixSub\\"));if\\n       );if\\r\\n      );defn" "(MatrixSub [1 2 3] [1 2 3])" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    ((let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input MatrixAdd\\")\\r\\n    );if\\r\\n    );if\\r\\n   );defn\\n \\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (row-number mat1) (VectorSub mat1 mat2) \\r\\n       ((let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input MatrixSub\\"));if\\r\\n       );if\\r\\n      );defn\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) \\"wrong input dot-product \\");if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (let [sum ( mapv + vec1 vec2)] sum))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (let [sub ( mapv - vec1 vec2)]\\r\\n          sub);let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n       \\"wrong input row-number\\");if\\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     \\"wrong input col-number \\" );if\\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  );defn\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     \\"wrong input index-of-cells\\" );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat] \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)) \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(MatrixAdd matrix3 matrix1)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    ((let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n    ));if\\r\\n   );defn" "(MatrixAdd matrix3 matrix1)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    ((let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix));let\\r\\n    \\"Wrong input MatrixAdd\\"\\n              \\r\\n    );if\\r\\n    );if\\r\\n   );defn" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   ((if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix));let\\r\\n    \\"Wrong input MatrixAdd\\"          \\r\\n    );if\\r\\n    );if\\r\\n   );defn" "(MatrixAdd matrix3 matrix1)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    ((let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix));let\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\n              \\r\\n    \\r\\n    );if\\r\\n   );defn" "(MatrixAdd matrix3 matrix1)" "(MatrixAdd matrix1 matrix1)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (row-number mat1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix\\n      );let\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n   );defn" "(MatrixAdd matrix1 matrix1)" "(MatrixAdd matrix1 matrix13)" "(MatrixAdd matrix1 matrix3)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (\= (row-number mat1) 1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix\\n      );let\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n   );defn" "(MatrixAdd matrix1 matrix3)" "(MatrixAdd matrix1 matrix1)" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (\= (row-number mat1) 1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\n  \\r\\n    \\"Wrong input MatrixAdd\\"\\n      );if\\r\\n    );if\\r\\n   );defn" "(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (\= (row-number mat1) 1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix);let\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n   );defn" "(MatrixAdd matrix1 matrix1)" "(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (\= (row-number mat1)1) (VectorSub mat1 mat2) \\r\\n       ((let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n       \\"Wrong input MatrixSub\\"));if\\r\\n       );if\\r\\n      );defn" "(MatrixSub matrix1 matrix1)" "(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (\= (row-number mat1)1) (VectorSub mat1 mat2) \\r\\n       (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\n         );if\\r\\n       \\"Wrong input MatrixSub\\"\\r\\n       );if\\r\\n      );defn" "(MatrixSub matrix1 matrix1)" "(MatrixSub matrix1 matrix3)" "(MatrixSub matrix3 matrix3)" "(MatrixSub matrix2 matrix3)" "(MatrixSub matrix2 matrix2)" "(MatrixSub matrix8 matrix2)" "(MatrixSub matrix8 matrix1)" "(MatrixSub matrix3 matrix1)" "(MatrixSub matrix3 matrix7)" "(MatrixSub matrix3 matrix8)" "(MatrixSub matrix3 [])" "(super-MatrixAdd matrix2)" "(super-MatrixAdd matrix2 matrix2)" "(super-MatrixAdd matrix1 matrix3)" "(super-MatrixAdd matrix3 matrix3)" "(VectorAdd [1 2 3] [1 2])" "(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\r\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (if (\= (col-number vec1) (col-number vec2)) (let [sum ( mapv + vec1 vec2)] sum) \\"wrong input vectorAdd\\"))\\r\\n       ([vec1 vec2 vec3] (let [sum ( mapv + vec1 vec2 vec3)] sum)) \\r\\n        );defn" "(VectorAdd [1 2 3] [1 2])" "(VectorAdd [1 2 3] [1 2 3])" "(VectorAdd [1 2 ] [1 2 3])" "(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\r\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (if (\= (col-number vec1) (col-number vec2)) (let [sum ( mapv + vec1 vec2)] sum) \\"wrong input vectorAdd\\"))\\r\\n       ([vec1 vec2 vec3] (if (\= (col-number vec1) (col-number vec2) (col-number vec3))) (let [sum ( mapv + vec1 vec2 vec3)] sum) \\"wrong input vectorAdd\\")) \\r\\n        );defn" "(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\r\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (if (\= (col-number vec1) (col-number vec2)) (let [sum ( mapv + vec1 vec2)] sum) \\"wrong input vectorAdd\\"))\\r\\n       ([vec1 vec2 vec3] (if (\= (col-number vec1) (col-number vec2) (col-number vec3)) (let [sum ( mapv + vec1 vec2 vec3)] sum) \\"wrong input vectorAdd\\")) \\r\\n        );defn" "(VectorAdd [1 2 ] [1 2 3] [1])" "(VectorAdd [1 2 ] [1 2 3] [1 2])" "(VectorAdd [1 2 ] [1 2 ] [1 2])" "(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\r\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (if (\= (col-number vec1) (col-number vec2))(let [sub ( mapv - vec1 vec2)]\\r\\n          sub) \\"wrong input VectorSub\\");let\\r\\n        );defn" "(VectorSub [1 2 ] [1 2 ] [1 2])" "(VectorSub [1 2 ] [1 2 ])" "(VectorSub [1 2 ] [1 3 ])" "(VectorSub [1 2 ] [1 3 2])" "(VectorSub [1 2 3] [1 3 2])" "(VectorSub [ 2 3] [1 3 2])" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) \\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (\= (row-number mat1) 1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix\\r\\n      );let\\r\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n   );defn\\n\\n\\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (\= (row-number mat1)1) (VectorSub mat1 mat2) \\r\\n       (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n         );if\\r\\n       \\"Wrong input MatrixSub\\"\\r\\n       );if\\r\\n      );defn\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) \\"wrong input dot-product \\");if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\r\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (if (\= (col-number vec1) (col-number vec2)) (let [sum ( mapv + vec1 vec2)] sum) \\"wrong input vectorAdd\\"))\\r\\n       ([vec1 vec2 vec3] (if (\= (col-number vec1) (col-number vec2) (col-number vec3)) (let [sum ( mapv + vec1 vec2 vec3)] sum) \\"wrong input vectorAdd\\")) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\r\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (if (\= (col-number vec1) (col-number vec2))(let [sub ( mapv - vec1 vec2)]\\r\\n          sub) \\"wrong input VectorSub\\");let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n       \\"wrong input row-number\\");if\\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     \\"wrong input col-number \\" );if\\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  );defn\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     \\"wrong input index-of-cells\\" );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat] \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)) \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n;to run the project test,please excute the following command.\\n(run-tests 'MatrixCalculator.core-test)\\r\\n" "(time(value-of (MatrixMult \\r\\n               (Create-Matrix-const-size 100 100)\\r\\n               (Create-Matrix-const-size 100 100)\\r\\n               ) 5 9))" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-Matrix-const-size 100 100)\\r\\n;               (Create-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\") (run \\"FNE\\" matrix1 matrix2))\\n  (is (\= \\"Wrong input MatrixAdd\\") (run \\"+\\" matrix1 matrix3))\\n  (is (\= false ) (CheckMatrix matrix2))\\n  )\\n\\n\\n(deftest test-index-of-cell\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\n   (is (\= ())\\n        (run \\"IOC\\" > (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       )\\n  )\\n\\n(deftest test-check \\r\\n  (are [x y] (\= x y)\\r\\n     false (CheckMatrix matrix2)\\r\\n     true  (CheckMatrix matrix3)\\r\\n     false (CheckMultiply matrix1 matrix7)\\r\\n     true  (CheckMultiply matrix1 matrix3)\\r\\n     false (Check_addition matrix1 matrix3)\\r\\n     true  (Check_addition matrix3 matrix3)\\r\\n      )\\r\\n  )\\n\\n(run-tests)\\n\\n(clojure.core/ns MatrixCalculator.core)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n;to run the project tests,please excute the following command.\\r\\n;(run-tests 'MatrixCalculator.core-test)\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) ;empty matrix.\\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (\= (row-number mat1) 1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix\\r\\n      );let\\r\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n   );defn\\n\\n\\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (\= (row-number mat1)1) (VectorSub mat1 mat2) \\r\\n       (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n         );if\\r\\n       \\"Wrong input MatrixSub\\"\\r\\n       );if\\r\\n      );defn\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) \\"wrong input dot-product \\");if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\r\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (if (\= (col-number vec1) (col-number vec2)) (let [sum ( mapv + vec1 vec2)] sum) \\"wrong input vectorAdd\\"))\\r\\n       ([vec1 vec2 vec3] (if (\= (col-number vec1) (col-number vec2) (col-number vec3)) (let [sum ( mapv + vec1 vec2 vec3)] sum) \\"wrong input vectorAdd\\")) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\r\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (if (\= (col-number vec1) (col-number vec2))(let [sub ( mapv - vec1 vec2)]\\r\\n          sub) \\"wrong input VectorSub\\");let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n       \\"wrong input row-number\\");if\\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     \\"wrong input col-number \\" );if\\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  );defn\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     \\"wrong input index-of-cells\\" );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat] \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)) \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n\\r\\n" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-Matrix-const-size 100 100)\\r\\n;               (Create-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\") (run \\"FNE\\" matrix1 matrix2))\\n  (is (\= \\"Wrong input MatrixAdd\\") (run \\"+\\" matrix1 matrix3))\\n  (is (\= false ) (CheckMatrix matrix2))\\n  )\\n\\n\\n(deftest test-index-of-cell\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\n   (is (\= ())\\n        (run \\"IOC\\" > (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       )\\n  )\\n\\n(deftest test-check \\r\\n  (are [x y] (\= x y)\\r\\n     false (CheckMatrix matrix2)\\r\\n     true  (CheckMatrix matrix3)\\r\\n     false (CheckMultiply matrix1 matrix7)\\r\\n     true  (CheckMultiply matrix1 matrix3)\\r\\n     false (Check_addition matrix1 matrix3)\\r\\n     true  (Check_addition matrix3 matrix3)\\r\\n      )\\r\\n  )\\n\\n(run-tests)\\n\\n(clojure.core/ns MatrixCalculator.core)" "(clojure.core/ns MatrixCalculator.exampels)\\n(ns MatrixCalculator.exampels\\n  (\:use [MatrixCalculator.core]) )\\n\\n(input1 \\"mat_A_10_10\\")\\n\\n(input2 \\"mat_B_10_10\\")\\n\\n(run \\"SM\\" (run \\"t\\" matrix1))\\n\\n(run \\"SM\\" (run \\"++\\" (CreateMatrix) (CreateMatrix)))\\r\\n\\n(run \\"SM\\" (run \\"+\\" (Create-Matrix-const-size 10 10) (Create-Matrix-const-size 10 10)))\\r\\n\\n(ShowMatrix(run \\"*\\" (input) (input)  ))\\n\\n(ShowMatrix(run \\"-\\" (input) (input)  ))\\n\\n(run-from-file \\"functions.txt\\" (input1 \\"mat_A_10_10\\") (input2 \\"mat_B_10_10\\"))\\n\\n(run-from-file \\"functions.txt\\" (input) (input))\\n\\n(run \\"RRIM\\" matrix8)\\n\\n(run \\"WMIF\\" \\"mat_random\\")\\n\\n(run \\"WMIF\\" \\"mat_A_5_8\\" 5 8)\\n\\n(run \\"WMIF\\" \\"vector\\" (vec (flatten (run \\"CM\\"))))\\n\\n(ShowMatrix matrix1) (ShowMatrix(run \\"t\\" matrix1))\\n\\n(run \\"RRIM\\" (run \\"t\\" (run \\"CLPM\\")))\\n\\n(run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_B_10_10\\"))\\n(clojure.core/ns MatrixCalculator.core)" ";; Switching to MatrixCalculator.core namespace" "(ns MatrixCalculator.core\\r\\n  (\:use [clojure.test] )\\n  (\:use [clojure.java.io])\\n  )\\r\\n\\n\\n\\n(defn -main\\n  \\"I don't do a whole lot.\\"\\n  [& args]\\n  (println \\"Hello, World\!\\"))\\n\\n;to run the project tests,please excute the following command.\\r\\n;(run-tests 'MatrixCalculator.core-test)\\n\\n(def matrix1 [[1 2 3][4 5 6]])\\n(def matrix2 [[1 2][1 2 3]]) ;illegal matrix\\n(def matrix3 [[1 2 3][4 5 6][7 8 9]])\\n(def matrix5 [[1 2][3 4][5 6]])\\n(def matrix6 [[4 5 6][1 2 3]])\\n(def matrix7 [[5 7 9][5 7 9]])\\n(def matrix8 [[1 2 3] [1 2 3] [4 5 6]])\\n(def empty-matrix []) ;empty matrix.\\n\\n\\r\\n\\r\\n(defn CreateMatrix [] \\r\\n  \\"creats a new random matrix\\"\\r\\n  (let [ row (rand-int 10) col (rand-int 10)]\\r\\n    (loop [ result [] n (* row col)]\\r\\n      (if(zero? n)\\r\\n      (map vec (partition row result))\\r\\n    (recur (conj result (rand-int 100))  (dec n)))\\r\\n    );loop\\r\\n    );let\\r\\n   );defn\\n\\n\\r\\n\\n(defn Create-lazy-positiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random positive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (positive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-lazy-negitiveNumbers-Matrix [] \\r\\n     \\"creats a new matrix with random nagitive values and random dimensions.\\"\\r\\n     (let [ col (rand-int 30)  step (rand-int 10)]\\r\\n       (loop [ result [] row (rand-int 10)]\\r\\n         (if(zero? row)\\r\\n        result\\r\\n       (recur (conj result \\r\\n                (vec(shuffle(take col (negitive-numbers))))    );conj  \\r\\n              (dec row))\\r\\n       );if\\r\\n       );loop\\r\\n       );let\\r\\n      );defn\\n\\n\\n\\n(defn Create-Matrix-const-size [row1 col1] \\r\\n  \\"creats a new matrix with random values and given dimentions\\"\\r\\n  (if (or (<\= row1 0)  (<\= col1 0)) (print \\"dimensions must be positive\\")\\r\\n  (let [ col col1  step (rand-int 10)]\\r\\n    (loop [ result [] row row1]\\r\\n      (if(zero? row)\\r\\n     result\\r\\n    (recur (conj result \\r\\n             (vec(shuffle(take col (range))))    );conj  \\r\\n           (dec row))\\r\\n    );if\\r\\n    );loop\\r\\n    );let\\r\\n  );if\\r\\n   );defn\\n\\n\\n\\n(defn MatrixAdd\\r\\n  \\"return the the sum of two matrix\\"\\r\\n  [mat1 mat2]\\r\\n  (if (and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n   (if (\= (row-number mat1) 1) (VectorAdd mat1 mat2) \\r\\n    (let [SumMatrix (mapv VectorAdd mat1 mat2)]\\r\\n    SumMatrix\\r\\n      );let\\r\\n    );if\\r\\n    \\"Wrong input MatrixAdd\\"\\r\\n    );if\\r\\n   );defn\\n\\n\\n\\r\\n(defn super-MatrixAdd\\r\\n  \\"return the the sum of two/three/four/five matrix\\"\\r\\n  ([mat1 mat2] (let [SumMatrix (mapv VectorAdd mat1 mat2)] SumMatrix))\\r\\n  ([mat1 mat2 mat3] (let [SumMatrix (mapv VectorAdd mat1 mat2 mat3)] SumMatrix)) \\r\\n  ([mat1 mat2 mat3 mat4] (super-MatrixAdd (super-MatrixAdd mat1 mat2) (super-MatrixAdd mat3 mat4)) )\\r\\n  ([mat1 mat2 mat3 mat4 mat5] (super-MatrixAdd (super-MatrixAdd mat1 mat2 mat3) (super-MatrixAdd mat4 mat5))) \\r\\n  );defn\\n\\n\\n\\n(defn MatrixSub\\r\\n     \\"return the the submition of two matrix\\"\\r\\n     [mat1 mat2]\\r\\n     (if(and (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2) ) \\r\\n       (if (\= (row-number mat1)1) (VectorSub mat1 mat2) \\r\\n       (let [SubMatrix (mapv VectorSub mat1 mat2)]\\r\\n       SubMatrix);let\\r\\n         );if\\r\\n       \\"Wrong input MatrixSub\\"\\r\\n       );if\\r\\n      );defn\\n \\n(defn transpose\\r\\n     \\"returns the transposition of a `coll` of vectors\\"\\r\\n     [coll]\\r\\n     {\:pre [(not (integer? coll)) (not (float? coll)) (not (string? coll))]} \\r\\n     (if (vector? (first coll)) \\r\\n       (apply map vector coll)\\r\\n       (map vector coll)\\r\\n     );if\\r\\n   );defn\\n \\n\\n\\n(defn Check_addition\\n   \\"checks that both matrix got the same dimentions\\"\\n   [mat1 mat2]\\n  (if(not\= (count mat1) (count mat2)) false \\r\\n    (do\\r\\n      (if(not\= (count (transpose mat1)) (count (transpose mat2)) ) false true);if\\n      );do\\r\\n    );if\\n   );defn\\n\\n\\n\\n(defn CheckMatrix [mat]\\r\\n  \\"cheks that all rows are in the same length.\\"\\r\\n  (if (or (\= (count (transpose mat)) 1) (\= (count mat) 1) (not (vector? (first mat)))) true\\r\\n  (loop [my_mat (map count mat) i (first my_mat)]\\r\\n       (if(empty? my_mat) true\\r\\n       ( if(not\= i (first my_mat)) false \\r\\n        (recur (rest my_mat) (first my_mat)))\\n       );if\\n       );loop\\r\\n      );if\\r\\n      );defn\\r\\n \\n\\n\\n(defn dot-product [x y]\\r\\n   \\"return the dot product of two vectors.\\" \\r\\n      (if (and (not\= [] x) (not\= [] y) (\= 1 (row-number x)) (\= 1 (row-number y))(\= (col-number x) (col-number y)) ) \\r\\n      (reduce + (pmap * x y)) \\"wrong input dot-product \\");if\\r\\n     );defn\\n \\n\\n\\n(defn VectorAdd\\r\\n        \\"return the sum of two vectors.\\r\\n        (this function used in Matrixadd and super-MatrixAdd)\\"\\r\\n       ([vec1 vec2] (if (\= (col-number vec1) (col-number vec2)) (let [sum ( mapv + vec1 vec2)] sum) \\"wrong input vectorAdd\\"))\\r\\n       ([vec1 vec2 vec3] (if (\= (col-number vec1) (col-number vec2) (col-number vec3)) (let [sum ( mapv + vec1 vec2 vec3)] sum) \\"wrong input vectorAdd\\")) \\r\\n        );defn\\n \\n\\n\\n(defn VectorSub\\r\\n        \\"return the submition of two vectors.\\r\\n        (this function used in MatrixSub).\\"\\r\\n        [vec1 vec2]\\r\\n        (if (\= (col-number vec1) (col-number vec2))(let [sub ( mapv - vec1 vec2)]\\r\\n          sub) \\"wrong input VectorSub\\");let\\r\\n        );defn\\n\\n\\n\\n(defn ShowMatrix \\r\\n     \\"print the matrix.each row in a new line.\\n      when it gets more than one matrix, it's print each matrix in new line.\\"\\r\\n     ([mat] (mapv (fn [vec] (println vec) ) mat))\\r\\n     );defn\\r\\n     \\n \\n \\n(defn CheckMultiply \\r\\n  \\"checks that the number of columns of the first matrix\\r\\n   is equal to the number of rows of the second matrix.\\"\\r\\n  [mat1 mat2]\\r\\n  (\= (col-number mat1) (row-number mat2))\\r\\n  );defn\\n \\n\\n\\n\\n(defn row-number \\r\\n     \\"return the number of rows in a matrix\\"\\r\\n      [mat]\\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat) ) \\r\\n      (if (vector? (first mat))\\r\\n       (count mat) 1);if \\n       \\"wrong input row-number\\");if\\r\\n     );defn\\n\\n\\n\\n(defn col-number \\r\\n     \\"return the number of columns in a matrix\\" \\r\\n     [mat] \\r\\n     (if (and (vector? mat) (not\= (first mat) nil) (CheckMatrix mat))\\r\\n     ((comp count transpose )mat) \\n     \\"wrong input col-number \\" );if\\r\\n     );defn\\n \\n \\n \\n(defn mult-vec-mat\\r\\n     \\"return  the product of a vector and matrix.\\n      (this function used in MatrixMult).\\"\\r\\n     [vec mat]\\r\\n     (loop [mat_trans (transpose mat) \\r\\n               result '[]]\\r\\n          (if (empty? mat_trans)\\r\\n            result\\r\\n              (recur (rest mat_trans) (conj result (dot-product vec (first mat_trans))) ) \\r\\n              );if\\r\\n          );loop\\r\\n     );defn\\n \\n \\n\\n(defn  MatrixMult  [mat1 mat2]\\r\\n  \\"gets 2 matrix and return the product of the two matrix.\\"  \\r\\n  (if (CheckMultiply mat1 mat2) \\r\\n  (if (\= (row-number mat1) 1)  (mult-vec-mat mat1 mat2)  \\r\\n  (loop [mat1_temp mat1\\r\\n         result '[]]\\r\\n    (if (empty? mat1_temp)\\r\\n       result\\r\\n        (recur (rest mat1_temp) \\r\\n               (conj result (mult-vec-mat (first mat1_temp) mat2)) );recur\\r\\n      );if\\r\\n    );loop\\r\\n  );if\\r\\n  \\"wrong input MatrixMult\\");if\\r\\n  );defn\\n\\n\\r\\n(defn value-of \\r\\n  \\"gets a matrix and index and return the value in this index.\\" \\r\\n  [matrix row col] \\r\\n  {\:pre [(CheckMatrix matrix) (< row (row-number matrix)) (< col (col-number matrix))]}\\r\\n   (if (\=(row-number matrix) 1) (matrix col) ((matrix row) col)\\r\\n     );if\\r\\n  );defn\\n\\n\\n\\n(defn index-of-cells [f mat1 mat2 ]\\r\\n  \\"gets a bollean function and 2 matrix and return all the indexes that the\\r\\n   function return true when gets the 2 values in those indexes as inputs.\\" \\r\\n     (if (and (function? f) (CheckMatrix mat1) (CheckMatrix mat2) (Check_addition mat1 mat2)) \\r\\n     (let [rows (row-number mat1) cols (col-number mat2)]\\r\\n       (for [row (range rows)\\r\\n              col (range cols)    \\r\\n              \:let [x (value-of  mat1 row col) y (value-of  mat2 row col) ]  \\r\\n              \:when (f x y) ] \\r\\n     {\:r row \:c col} );for\\r\\n   );let\\r\\n     \\"wrong input index-of-cells\\" );if\\r\\n  );defn\\n \\n\\n\\r\\n(defn is-val-exsist-in-mat [mat1 value]\\r\\n  \\"if the value exist in the matrix,return the indexes of that value,else return ()\\"\\r\\n {\:pre [(CheckMatrix mat1)]}\\r\\n  (let [rows (row-number mat1) cols (col-number mat1)]\\r\\n    (for [row (range rows)\\r\\n           col (range cols)    \\r\\n           \:let [x (value-of  mat1 row col)]  \\r\\n           \:when (\= x value) ] \\r\\n  {\:r row \:c col} );for\\r\\n   );let\\r\\n);defn\\n\\n\\n(defn multy-actions \\n  \\"preform few actions on a given input.\\n   if the input is 2 argument,return the sum , submition and product of the 2 matrix.\\n   if the input is 1 argument,return the transpose an the number of rows and colomons of the matrix\\n   and check that it is a valid matrix before that.  \\" \\r\\n  ([mat1 mat2] (( juxt  MatrixAdd MatrixSub MatrixMult)  mat1 mat2))\\r\\n  ([mat] (( juxt  CheckMatrix transpose col-number row-number)  mat ))\\r\\n  );defn\\n\\n\\n\\n(defn power-of-4\\r\\n   \\"return mat^4\\" \\r\\n     [mat] \\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy (mem-multy mat mat) (mem-multy mat mat)) \\r\\n     );defn\\n\\n\\n\\n(defn power-of-8\\r\\n   \\"return mat^8\\" \\r\\n     [mat]\\r\\n     (def mem-multy (memoize MatrixMult))\\r\\n     (mem-multy \\r\\n       (mem-multy(mem-multy mat mat) (mem-multy mat mat))\\r\\n       (mem-multy (mem-multy mat mat) (mem-multy mat mat))\\r\\n       );mem-multy\\r\\n     );defn\\n \\r\\n\\n \\n (defn combine \\n   \\"gets a key.\\n    if that key not exsist in the map,it entered to the map with value 1.\\n    if it do exsist it increase the value by 1.\\" \\r\\n            [countsSoFar nextElem] \\r\\n            (let [ num (\:key nextElem)\\r\\n                  numVal (countsSoFar num) ]\\r\\n              (assoc countsSoFar \\r\\n                     num (if numVal  (+ 1 numVal)  1);if\\r\\n               );assoc\\r\\n     );let    \\r\\n   );defn\\n\\n\\n \\n(defn repeted-row-in-matrix\\r\\n  \\"for matrix - return for each row, how many times it repeated in the matrix\\r\\n   for vector - return for each value, how many times it repeated in the vector.\\"\\r\\n   [matrix]\\r\\n   (reduce combine {} (map (fn numRank [num] {\:key num \:val 1}) matrix )) \\r\\n  );defn\\n\\n\\n\\n(defn positive-numbers\\n  \\"return a lazy sequens of positive numbers \\r\\n   starting from the given argument or from (1) if no arguments specfied.\\"\\r\\n    ([] (positive-numbers 1))\\r\\n    ([n] {\:pre [(> n 0)]} (cons n (lazy-seq (positive-numbers (inc n)))))\\n    );defn\\n \\n\\n\\n(defn negitive-numbers\\r\\n  \\"return a lazy sequens of negitive numbers \\r\\n   starting from the given argument or from (-1) if no arguments specfied.\\" \\r\\n       ([] (negitive-numbers -1))\\r\\n       ([n] {\:pre [(< n 0)]} (cons n (lazy-seq (negitive-numbers (dec n)))))\\r\\n       );defn\\n \\n\\n \\n(defmacro input\\n  \\"macro that reads the matrix1.txt file.\\" \\r\\n  []\\r\\n  (read-string (slurp \\"matrix1.txt\\"))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input1\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\n\\n\\n(defmacro input2\\r\\n  \\"macro that reads a matrix from a given file.\\" \\r\\n  [file-name]\\r\\n  (read-string (slurp file-name))\\r\\n  );defmacro\\n\\r\\n\\n\\n(defn write-mat-into-file\\n  \\"write a matrix into file in three options, depending on the number of arguments pass to the function\:\\n   3 arguments - write a matrix with random values but given dimensions to the given file. \\n   2 arguments - write the given matrix to the the given file.\\n   1 argument - write a fully random matrix tothe given file. \\" \\r\\n  ([file-name col row]   (spit file-name (Create-Matrix-const-size col row)))\\r\\n  ([file-name mat]  (spit file-name mat)) \\r\\n  ([file-name]  (spit file-name (Create-lazy-positiveNumbers-Matrix))) \\r\\n);defn\\n\\n\\n\\n(defn run-from-file\\n  \\"this function gets a file name that consist of a function name\\n   and one/two matrix and run the function from the file with the matrix as input.\\" \\r\\n  ([file-name mat1]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1) \\r\\n        );let\\n  ) ;2 arguments\\n  ([file-name mat1 mat2]\\r\\n  (let [func (-> (slurp file-name ) symbol resolve)] ( func mat1 mat2) \\n        );let\\n  );3 arguments\\r\\n );defn\\n\\n\\n\\n(def functions-map\\n  \\"this is the main map.the key of the map is the first argument that pass to the fuction run,\\n   the value of thats key is a pointer to the spesfic function.\\" \\r\\n     {\\"CM\\" CreateMatrix\\r\\n      \\"CLPM\\" Create-lazy-positiveNumbers-Matrix\\r\\n      \\"CLNM\\" Create-lazy-negitiveNumbers-Matrix\\r\\n      \\"CMCS\\" Create-Matrix-const-size\\n      \\"SM\\" ShowMatrix\\r\\n      \\"+\\" MatrixAdd \\r\\n      \\"++\\" super-MatrixAdd\\r\\n      \\"-\\" MatrixSub\\r\\n      \\"*\\" MatrixMult\\r\\n      \\"^4\\" power-of-4\\r\\n      \\"^8\\" power-of-8\\r\\n      \\"t\\" transpose\\r\\n      \\"DP\\" dot-product\\r\\n      \\"VA\\" VectorAdd\\r\\n      \\"VS\\" VectorSub\\r\\n      \\"RN\\" row-number\\r\\n      \\"CN\\" col-number \\r\\n      \\"VO\\" value-of\\r\\n      \\"IOC\\" index-of-cells\\r\\n      \\"IVEIM\\" is-val-exsist-in-mat\\r\\n      \\"MA\\" multy-actions\\r\\n      \\"RRIM\\" repeted-row-in-matrix\\n      \\"WMIF\\" write-mat-into-file\\n      \\"RFF\\"  run-from-file\\r\\n      }\\r\\n     )\\n\\n\\r\\n  \\r\\n(defn run\\n  \\"this is the only function that the user will execute.by excuting this function we call to other function that\\n   we want to execute and suplies the argument to that function as well.\\" \\r\\n  ([f] (if (nil? (functions-map f)) (print \\"function not exists(0)\\")  (let [func (functions-map f)] (func)     )))\\r\\n  ([f mat1] (if (nil? (functions-map f)) (print \\"function not exists(1)\\")  (let [func (functions-map f)] (func mat1)     ))  )\\r\\n  ([f mat1 mat2] (if (nil? (functions-map f)) (print \\"function not exists(2)\\")  (let [func (functions-map f)] (func mat1 mat2)     )) ) \\r\\n  ([f mat1 mat2 mat3] (if (nil? (functions-map f)) (print \\"function not exists(3)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3)     )))  \\r\\n  ([f mat1 mat2 mat3 mat4] (if (nil? (functions-map f)) (print \\"function not exists(4)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4)  )))\\r\\n  ([f mat1 mat2 mat3 mat4 mat5] (if (nil? (functions-map f)) (print \\"function not exists(5)\\")  (let [func (functions-map f)] (func mat1 mat2 mat3 mat4 mat5) )))\\n  );defn\\n\\n\\n\\n\\r\\n" "(clojure.core/ns MatrixCalculator.core-test)\\n(ns MatrixCalculator.core-test\\n  (\:use clojure.test\\n   ;MatrixCalculator.core\\n  [MatrixCalculator.core ])\\n  )\\n\\n;(deftest a-test\\n;  (testing \\"FIXME, I fail.\\"\\n;    (is (\= 0 1))))\\n\\n\\r\\n\\r\\n;(time(value-of (MatrixMult \\r\\n;               (Create-Matrix-const-size 100 100)\\r\\n;               (Create-Matrix-const-size 100 100)\\r\\n;               ) 5 9))\\r\\n\\r\\n\\n \\n ;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n;\#\#    tests\\r\\n;\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\r\\n\\r\\n (are [s1 s2 result]\\r\\n   \\t(\= (MatrixAdd s1 s2) result)\\r\\n       matrix1\\r\\n       matrix6\\r\\n       matrix7\\n       \\r\\n   )\\r\\n\\r\\n(deftest test-is-val-exsist\\r\\n  (is (\= ()\\r\\n        (is-val-exsist-in-mat matrix1 4096)\\r\\n     ) \\"not finding a not existing item in a matrix\\"\\r\\n     ) \\r\\n  (is (\= true)\\r\\n      (is-val-exsist-in-mat  ((comp power-of-4 power-of-4) [[1 1] [1 1]]) 32768)\\r\\n      )\\"finding an existing item in a matrix\\"\\r\\n)\\r\\n\\r\\n(deftest test-dot-product\\r\\n  (is (\= 14\\r\\n        (dot-product [1 2 3] [1 2 3])\\r\\n     ) \\"return the right value of dot product\\"\\r\\n))\\r\\n\\r\\n\\r\\n(deftest test-value-of\\r\\n  (are [x y] (\= x y)\\r\\n        2 (value-of matrix6 1 1)\\r\\n        8 (value-of matrix3 2 1)\\r\\n     ) \\"return the right value of the value in the following indexes\\"\\r\\n)\\r\\n\\n\\n(deftest test-MatrixSub\\r\\n  ( are [x y] (\= x y)\\r\\n       (run \\"-\\" (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"-\\" (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\n       )\\r\\n )\\n\\n(deftest test-wrong-input\\n  (is (\= \\"function not exsists\\") (run \\"FNE\\" matrix1 matrix2))\\n  (is (\= \\"Wrong input MatrixAdd\\") (run \\"+\\" matrix1 matrix3))\\n  (is (\= false ) (CheckMatrix matrix2))\\n  )\\n\\n\\n(deftest test-index-of-cell\\n   ( are [x y] (\= x y)\\r\\n       (run \\"IOC\\" \= (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\r\\n       (run \\"IOC\\" \= (input2 \\"mat_B_10_10\\") (input2 \\"mat_B_10_10\\"))\\r\\n       )\\n   (is (\= ())\\n        (run \\"IOC\\" > (input1 \\"mat_A_10_10\\") (input1 \\"mat_A_10_10\\"))\\n       )\\n  )\\n\\n(deftest test-check \\r\\n  (are [x y] (\= x y)\\r\\n     false (CheckMatrix matrix2)\\r\\n     true  (CheckMatrix matrix3)\\r\\n     false (CheckMultiply matrix1 matrix7)\\r\\n     true  (CheckMultiply matrix1 matrix3)\\r\\n     false (Check_addition matrix1 matrix3)\\r\\n     true  (Check_addition matrix3 matrix3)\\r\\n      )\\r\\n  )\\n\\n(run-tests)\\n\\n(clojure.core/ns MatrixCalculator.core)"]
eclipse.preferences.version=1
